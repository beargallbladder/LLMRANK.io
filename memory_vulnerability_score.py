"""
Memory Vulnerability Score Calculator

This module calculates and tracks Memory Vulnerability Scores (MVS) for brands and domains
across competitive categories, identifying entities at risk of being forgotten
or misrepresented by LLMs.
"""

import os
import json
import logging
import datetime
from typing import Dict, List, Optional, Tuple, Any
import statistics

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Constants
DATA_DIR = "data"
SURFACE_DIR = os.path.join(DATA_DIR, "surface")
PRIORITY_CATEGORIES_PATH = os.path.join(SURFACE_DIR, "priority_categories.json")
MVS_HISTORY_PATH = os.path.join(SURFACE_DIR, "mvs_history.json")
BRAND_SCORES_PATH = os.path.join(SURFACE_DIR, "brand_scores.json")

# Ensure directories exist
os.makedirs(SURFACE_DIR, exist_ok=True)

class MemoryVulnerabilityScoreCalculator:
    """
    Calculates and tracks Memory Vulnerability Scores (MVS) for brands and domains,
    identifying those at risk of being forgotten or misrepresented by LLMs.
    
    Also provides priority brand tracking for the "Flame Aware" system.
    """
    
    def __init__(self):
        """Initialize the Memory Vulnerability Score calculator."""
        self.categories = self._load_categories()
        self.mvs_history = self._load_mvs_history()
        self.brand_scores = self._load_brand_scores()
    
    def _load_categories(self) -> List[Dict]:
        """Load competitive categories from disk."""
        try:
            if os.path.exists(PRIORITY_CATEGORIES_PATH):
                with open(PRIORITY_CATEGORIES_PATH, 'r') as f:
                    data = json.load(f)
                    return data.get("fiercely_competitive_categories", [])
            else:
                logger.warning(f"Priority categories file not found at {PRIORITY_CATEGORIES_PATH}")
                return []
        except Exception as e:
            logger.error(f"Error loading competitive categories: {e}")
            return []
    
    def _load_mvs_history(self) -> Dict:
        """Load MVS history from disk."""
        try:
            if os.path.exists(MVS_HISTORY_PATH):
                with open(MVS_HISTORY_PATH, 'r') as f:
                    return json.load(f)
            else:
                # Create default structure
                history = {
                    "categories": {},
                    "brands": {},
                    "last_updated": datetime.datetime.now().isoformat()
                }
                
                # Save default history
                with open(MVS_HISTORY_PATH, 'w') as f:
                    json.dump(history, f, indent=2)
                
                return history
        except Exception as e:
            logger.error(f"Error loading MVS history: {e}")
            return {"categories": {}, "brands": {}, "last_updated": datetime.datetime.now().isoformat()}
    
    def _load_brand_scores(self) -> Dict:
        """Load brand scores from disk."""
        try:
            if os.path.exists(BRAND_SCORES_PATH):
                with open(BRAND_SCORES_PATH, 'r') as f:
                    return json.load(f)
            else:
                # Create default structure
                scores = {
                    "brands": {},
                    "last_updated": datetime.datetime.now().isoformat()
                }
                
                # Save default scores
                with open(BRAND_SCORES_PATH, 'w') as f:
                    json.dump(scores, f, indent=2)
                
                return scores
        except Exception as e:
            logger.error(f"Error loading brand scores: {e}")
            return {"brands": {}, "last_updated": datetime.datetime.now().isoformat()}
    
    def _save_mvs_history(self) -> bool:
        """Save MVS history to disk."""
        try:
            # Update last updated timestamp
            self.mvs_history["last_updated"] = datetime.datetime.now().isoformat()
            
            with open(MVS_HISTORY_PATH, 'w') as f:
                json.dump(self.mvs_history, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving MVS history: {e}")
            return False
    
    def _save_brand_scores(self) -> bool:
        """Save brand scores to disk."""
        try:
            # Update last updated timestamp
            self.brand_scores["last_updated"] = datetime.datetime.now().isoformat()
            
            with open(BRAND_SCORES_PATH, 'w') as f:
                json.dump(self.brand_scores, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving brand scores: {e}")
            return False
    
    def _save_categories(self) -> bool:
        """Save competitive categories to disk."""
        try:
            data = {
                "fiercely_competitive_categories": self.categories
            }
            
            with open(PRIORITY_CATEGORIES_PATH, 'w') as f:
                json.dump(data, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving competitive categories: {e}")
            return False
    
    def calculate_memory_vulnerability(self, brand: str, category: str) -> float:
        """
        Calculate the Memory Vulnerability Score for a brand in a specific category.
        
        Args:
            brand: Brand name
            category: Category name
            
        Returns:
            Memory Vulnerability Score (0-1)
        """
        # Base factors for MVS calculation
        factors = {
            "category_competitiveness": 0.0,    # How competitive is the category (0-1)
            "mention_frequency": 0.0,           # How often the brand is mentioned (0-1, inverted)
            "narrative_consistency": 0.0,       # How consistently the brand is represented (0-1, inverted)
            "distinctive_attributes": 0.0,      # How unique/distinctive the brand's attributes are (0-1)
            "recency_bias": 0.0                 # How recent is the brand's presence in discourse (0-1, inverted)
        }
        
        # Get category competitiveness from data
        for cat in self.categories:
            if cat.get("name") == category:
                factors["category_competitiveness"] = cat.get("memory_vulnerability", 0.5)
                break
        
        # For now, simulate other factors - in real implementation, these would be calculated
        # from LLM responses, web scraping, etc.
        
        # Mention frequency - scale of 0 to 1, lower is better (mentioned more)
        # Invert so higher means more vulnerable
        factors["mention_frequency"] = 0.3  # Simulated value
        
        # Narrative consistency - scale of 0 to 1, lower is better (more consistent)
        # Invert so higher means more vulnerable
        factors["narrative_consistency"] = 0.4  # Simulated value
        
        # Distinctive attributes - scale of 0 to 1, higher is better (more distinctive)
        factors["distinctive_attributes"] = 0.6  # Simulated value
        
        # Recency bias - scale of 0 to 1, lower is better (more recent)
        # Invert so higher means more vulnerable
        factors["recency_bias"] = 0.2  # Simulated value
        
        # Calculate weighted score
        weights = {
            "category_competitiveness": 0.3,
            "mention_frequency": 0.25,
            "narrative_consistency": 0.2,
            "distinctive_attributes": 0.15,
            "recency_bias": 0.1
        }
        
        score = sum(factors[k] * weights[k] for k in factors)
        
        # Ensure score is between 0 and 1
        score = max(0.0, min(1.0, score))
        
        return score
    
    def get_category_vulnerability(self, category_name: str) -> float:
        """
        Get the Memory Vulnerability Score for a category.
        
        Args:
            category_name: Category name
            
        Returns:
            Memory Vulnerability Score (0-1)
        """
        for category in self.categories:
            if category.get("name") == category_name:
                return category.get("memory_vulnerability", 0.5)
        
        return 0.5  # Default mid-range value
    
    def update_category_vulnerability(self, category_name: str, score: float) -> bool:
        """
        Update the Memory Vulnerability Score for a category.
        
        Args:
            category_name: Category name
            score: New Memory Vulnerability Score (0-1)
            
        Returns:
            Success flag
        """
        # Ensure score is between 0 and 1
        score = max(0.0, min(1.0, score))
        
        # Update category score
        for category in self.categories:
            if category.get("name") == category_name:
                category["memory_vulnerability"] = score
                category["last_evaluated"] = datetime.datetime.now().isoformat()
                
                # Save categories
                success = self._save_categories()
                
                # Update history
                if category_name not in self.mvs_history["categories"]:
                    self.mvs_history["categories"][category_name] = []
                
                self.mvs_history["categories"][category_name].append({
                    "timestamp": datetime.datetime.now().isoformat(),
                    "score": score
                })
                
                # Save history
                self._save_mvs_history()
                
                return success
        
        return False  # Category not found
    
    def get_brand_score(self, brand_name: str) -> Dict:
        """
        Get the Memory Vulnerability Score and details for a brand.
        
        Args:
            brand_name: Brand name
            
        Returns:
            Brand score details
        """
        brands = self.brand_scores.get("brands", {})
        
        if brand_name in brands:
            return brands[brand_name]
        
        # If brand not found, return empty details
        return {
            "name": brand_name,
            "overall_score": 0.5,  # Default mid-range value
            "category_scores": {},
            "history": [],
            "last_evaluated": None
        }
    
    def update_brand_score(self, brand_name: str, category_name: str, score: Optional[float] = None, priority: Optional[bool] = None) -> Dict:
        """
        Update the Memory Vulnerability Score for a brand in a specific category.
        
        Args:
            brand_name: Brand name
            category_name: Category name
            score: Optional score override (if None, will be calculated)
            priority: Optional priority flag for "Flame Aware" system
            
        Returns:
            Updated brand score details
        """
        # Calculate score if not provided
        if score is None:
            score = self.calculate_memory_vulnerability(brand_name, category_name)
        
        # Ensure score is between 0 and 1
        score = max(0.0, min(1.0, score))
        
        # Get or create brand entry
        brands = self.brand_scores.get("brands", {})
        
        if brand_name not in brands:
            brands[brand_name] = {
                "name": brand_name,
                "overall_score": score,
                "category_scores": {},
                "priority_categories": {},
                "history": [],
                "last_evaluated": datetime.datetime.now().isoformat()
            }
        
        # Update category score
        brands[brand_name]["category_scores"][category_name] = score
        
        # Update priority flag if provided
        if priority is not None:
            brands[brand_name]["priority_categories"][category_name] = priority
        
        # Update overall score (average of all category scores)
        category_scores = list(brands[brand_name]["category_scores"].values())
        brands[brand_name]["overall_score"] = sum(category_scores) / len(category_scores)
        
        # Update history
        brands[brand_name]["history"].append({
            "timestamp": datetime.datetime.now().isoformat(),
            "category": category_name,
            "score": score
        })
        
        # Limit history to 100 entries
        if len(brands[brand_name]["history"]) > 100:
            brands[brand_name]["history"] = brands[brand_name]["history"][-100:]
        
        # Update last evaluated
        brands[brand_name]["last_evaluated"] = datetime.datetime.now().isoformat()
        
        # Save brand scores
        self.brand_scores["brands"] = brands
        self._save_brand_scores()
        
        # Update MVS history
        if brand_name not in self.mvs_history["brands"]:
            self.mvs_history["brands"][brand_name] = []
        
        self.mvs_history["brands"][brand_name].append({
            "timestamp": datetime.datetime.now().isoformat(),
            "category": category_name,
            "score": score
        })
        
        # Save MVS history
        self._save_mvs_history()
        
        return brands[brand_name]
    
    def get_most_vulnerable_categories(self, limit: int = 5) -> List[Dict]:
        """
        Get the most vulnerable categories.
        
        Args:
            limit: Maximum number of categories to return
            
        Returns:
            List of category details sorted by vulnerability score (highest first)
        """
        # Sort categories by vulnerability score
        sorted_categories = sorted(
            self.categories,
            key=lambda c: c.get("memory_vulnerability", 0),
            reverse=True
        )
        
        # Return top N categories
        return sorted_categories[:limit]
    
    def get_most_vulnerable_brands(self, limit: int = 10, category: Optional[str] = None) -> List[Dict]:
        """
        Get the most vulnerable brands, optionally filtered by category.
        
        Args:
            limit: Maximum number of brands to return
            category: Optional category filter
            
        Returns:
            List of brand details sorted by vulnerability score (highest first)
        """
        brands = list(self.brand_scores.get("brands", {}).values())
        
        # Filter by category if specified
        if category:
            filtered_brands = []
            for brand in brands:
                if category in brand.get("category_scores", {}):
                    # Use the category-specific score for sorting
                    brand_copy = brand.copy()
                    brand_copy["sort_score"] = brand["category_scores"][category]
                    filtered_brands.append(brand_copy)
            brands = filtered_brands
        else:
            # Use overall score for sorting
            for brand in brands:
                brand["sort_score"] = brand.get("overall_score", 0)
        
        # Sort brands by vulnerability score
        sorted_brands = sorted(
            brands,
            key=lambda b: b.get("sort_score", 0),
            reverse=True
        )
        
        # Return top N brands
        return sorted_brands[:limit]
    
    def get_category_brands(self, category_name: str) -> List[str]:
        """
        Get all brands in a specific category.
        
        Args:
            category_name: Category name
            
        Returns:
            List of brand names
        """
        for category in self.categories:
            if category.get("name") == category_name:
                return category.get("top_brands", [])
        
        return []  # Category not found
    
    def update_brand_priority(self, brand_name: str, category_name: str, priority: bool) -> bool:
        """
        Update a brand's priority flag in a specific category for the "Flame Aware" system.
        
        Args:
            brand_name: Brand name
            category_name: Category name
            priority: Priority flag (True = high priority)
            
        Returns:
            Success flag
        """
        # Get or create brand entry
        brands = self.brand_scores.get("brands", {})
        
        if brand_name not in brands:
            # Create a new brand entry with default score and priority flag
            score = 0.5  # Default mid-range value
            self.update_brand_score(brand_name, category_name, score, priority)
            return True
        
        # Update priority flag
        if "priority_categories" not in brands[brand_name]:
            brands[brand_name]["priority_categories"] = {}
        
        brands[brand_name]["priority_categories"][category_name] = priority
        
        # Update last evaluated timestamp
        brands[brand_name]["last_evaluated"] = datetime.datetime.now().isoformat()
        
        # Log the priority change
        brands[brand_name]["history"].append({
            "timestamp": datetime.datetime.now().isoformat(),
            "category": category_name,
            "action": "priority_change",
            "priority": priority
        })
        
        # Limit history to 100 entries
        if len(brands[brand_name]["history"]) > 100:
            brands[brand_name]["history"] = brands[brand_name]["history"][-100:]
        
        # Save brand scores
        self.brand_scores["brands"] = brands
        self._save_brand_scores()
        
        return True
        
    def calculate_all_brand_scores(self, category_name: str) -> List[Dict]:
        """
        Calculate scores for all brands in a category.
        
        Args:
            category_name: Category name
            
        Returns:
            List of brand score details
        """
        brands = self.get_category_brands(category_name)
        results = []
        
        for brand in brands:
            brand_score = self.update_brand_score(brand, category_name)
            results.append(brand_score)
        
        return results
    
    def get_score_history(self, entity_name: str, is_brand: bool = True) -> List[Dict]:
        """
        Get the score history for a brand or category.
        
        Args:
            entity_name: Brand or category name
            is_brand: Whether the entity is a brand (True) or category (False)
            
        Returns:
            List of historical scores
        """
        if is_brand:
            return self.mvs_history.get("brands", {}).get(entity_name, [])
        else:
            return self.mvs_history.get("categories", {}).get(entity_name, [])
    
    def get_memory_drift(self, entity_name: str, is_brand: bool = True, days: int = 30) -> float:
        """
        Calculate memory drift over time for a brand or category.
        
        Args:
            entity_name: Brand or category name
            is_brand: Whether the entity is a brand (True) or category (False)
            days: Time period in days
            
        Returns:
            Drift amount (-1 to 1, negative means improving, positive means worsening)
        """
        history = self.get_score_history(entity_name, is_brand)
        
        if not history or len(history) < 2:
            return 0.0  # Not enough data
        
        # Filter history to specified time period
        now = datetime.datetime.now()
        cutoff = now - datetime.timedelta(days=days)
        cutoff_str = cutoff.isoformat()
        
        recent_history = [h for h in history if h.get("timestamp", "") >= cutoff_str]
        
        if not recent_history or len(recent_history) < 2:
            return 0.0  # Not enough data in time period
        
        # Sort by timestamp
        sorted_history = sorted(recent_history, key=lambda h: h.get("timestamp", ""))
        
        # Calculate drift (last score - first score)
        first_score = sorted_history[0].get("score", 0)
        last_score = sorted_history[-1].get("score", 0)
        
        return last_score - first_score


# Singleton instance
_mvs_calculator = None

def get_mvs_calculator() -> MemoryVulnerabilityScoreCalculator:
    """
    Get the Memory Vulnerability Score calculator singleton instance.
    
    Returns:
        Memory Vulnerability Score calculator instance
    """
    global _mvs_calculator
    if _mvs_calculator is None:
        _mvs_calculator = MemoryVulnerabilityScoreCalculator()
    return _mvs_calculator

def calculate_memory_vulnerability(brand: str, category: str) -> float:
    """
    Calculate the Memory Vulnerability Score for a brand in a specific category.
    
    Args:
        brand: Brand name
        category: Category name
        
    Returns:
        Memory Vulnerability Score (0-1)
    """
    return get_mvs_calculator().calculate_memory_vulnerability(brand, category)

def get_category_vulnerability(category_name: str) -> float:
    """
    Get the Memory Vulnerability Score for a category.
    
    Args:
        category_name: Category name
        
    Returns:
        Memory Vulnerability Score (0-1)
    """
    return get_mvs_calculator().get_category_vulnerability(category_name)

def update_category_vulnerability(category_name: str, score: float) -> bool:
    """
    Update the Memory Vulnerability Score for a category.
    
    Args:
        category_name: Category name
        score: New Memory Vulnerability Score (0-1)
        
    Returns:
        Success flag
    """
    return get_mvs_calculator().update_category_vulnerability(category_name, score)

def get_brand_score(brand_name: str) -> Dict:
    """
    Get the Memory Vulnerability Score and details for a brand.
    
    Args:
        brand_name: Brand name
        
    Returns:
        Brand score details
    """
    return get_mvs_calculator().get_brand_score(brand_name)

def update_brand_score(brand_name: str, category_name: str, score: Optional[float] = None) -> Dict:
    """
    Update the Memory Vulnerability Score for a brand in a specific category.
    
    Args:
        brand_name: Brand name
        category_name: Category name
        score: Optional score override (if None, will be calculated)
        
    Returns:
        Updated brand score details
    """
    return get_mvs_calculator().update_brand_score(brand_name, category_name, score)

def get_most_vulnerable_categories(limit: int = 5) -> List[Dict]:
    """
    Get the most vulnerable categories.
    
    Args:
        limit: Maximum number of categories to return
        
    Returns:
        List of category details sorted by vulnerability score (highest first)
    """
    return get_mvs_calculator().get_most_vulnerable_categories(limit)

def get_most_vulnerable_brands(limit: int = 10, category: Optional[str] = None) -> List[Dict]:
    """
    Get the most vulnerable brands, optionally filtered by category.
    
    Args:
        limit: Maximum number of brands to return
        category: Optional category filter
        
    Returns:
        List of brand details sorted by vulnerability score (highest first)
    """
    return get_mvs_calculator().get_most_vulnerable_brands(limit, category)

def get_category_brands(category_name: str) -> List[str]:
    """
    Get all brands in a specific category.
    
    Args:
        category_name: Category name
        
    Returns:
        List of brand names
    """
    return get_mvs_calculator().get_category_brands(category_name)

def calculate_all_brand_scores(category_name: str) -> List[Dict]:
    """
    Calculate scores for all brands in a category.
    
    Args:
        category_name: Category name
        
    Returns:
        List of brand score details
    """
    return get_mvs_calculator().calculate_all_brand_scores(category_name)

def update_brand_priority(brand_name: str, category_name: str, priority: bool) -> bool:
    """
    Update a brand's priority flag in a specific category for the "Flame Aware" system.
    
    Args:
        brand_name: Brand name
        category_name: Category name
        priority: Priority flag (True = high priority)
        
    Returns:
        Success flag
    """
    return get_mvs_calculator().update_brand_priority(brand_name, category_name, priority)

def get_score_history(entity_name: str, is_brand: bool = True) -> List[Dict]:
    """
    Get the score history for a brand or category.
    
    Args:
        entity_name: Brand or category name
        is_brand: Whether the entity is a brand (True) or category (False)
        
    Returns:
        List of historical scores
    """
    return get_mvs_calculator().get_score_history(entity_name, is_brand)

def get_memory_drift(entity_name: str, is_brand: bool = True, days: int = 30) -> float:
    """
    Calculate memory drift over time for a brand or category.
    
    Args:
        entity_name: Brand or category name
        is_brand: Whether the entity is a brand (True) or category (False)
        days: Time period in days
        
    Returns:
        Drift amount (-1 to 1, negative means improving, positive means worsening)
    """
    return get_mvs_calculator().get_memory_drift(entity_name, is_brand, days)


if __name__ == "__main__":
    # Test the Memory Vulnerability Score calculator
    logger.info("Testing Memory Vulnerability Score calculator")
    
    # Test category vulnerability scores
    categories = get_mvs_calculator().categories
    for category in categories[:3]:  # Test first 3 categories
        category_name = category.get("name")
        score = get_category_vulnerability(category_name)
        logger.info(f"Category: {category_name}, Vulnerability Score: {score:.2f}")
        
        # Test brand scores in this category
        brands = get_category_brands(category_name)
        for brand in brands[:2]:  # Test first 2 brands in each category
            brand_score = calculate_memory_vulnerability(brand, category_name)
            logger.info(f"  Brand: {brand}, Vulnerability Score: {brand_score:.2f}")
            
            # Update brand score
            updated_score = update_brand_score(brand, category_name)
            logger.info(f"  Updated Brand Score: {updated_score['overall_score']:.2f}")
    
    # Test most vulnerable categories
    vulnerable_categories = get_most_vulnerable_categories(3)
    logger.info("Most Vulnerable Categories:")
    for i, category in enumerate(vulnerable_categories):
        logger.info(f"  {i+1}. {category['name']}: {category['memory_vulnerability']:.2f}")
    
    # Test most vulnerable brands
    vulnerable_brands = get_most_vulnerable_brands(3)
    logger.info("Most Vulnerable Brands:")
    for i, brand in enumerate(vulnerable_brands):
        logger.info(f"  {i+1}. {brand['name']}: {brand['overall_score']:.2f}")
    
    logger.info("Memory Vulnerability Score calculator tests completed")